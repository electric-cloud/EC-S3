# WARNING
# Do not edit this file manually. Your changes will be overwritten with next FlowPDF update.
# WARNING

package FlowPDF::Client::REST::CertificateManagement;
use base qw/FlowPDF::BaseClass2/;
use strict;
use warnings;
use File::Temp;
use Carp;

use FlowPDF::Types;
use FlowPDF::Helpers qw/isLegacyPerl isEcPerl isCbPerl/;
use FlowPDF::Constants qw/
    CM_POLICY_STRICT
    CM_POLICY_SELFSIGNED
    CM_POLICY_IGNORE

    CM_LOCATION_TYPE_PROPERTY
    CM_LOCATION_TYPE_FILESYSTEM
    CM_LOCATION_TYPE_SDA_CERT_STORAGE
/;

# fields:
# cm policy
# cm location type
# cm location
__PACKAGE__->defineClass({
    cmPolicy => FlowPDF::Types::Enum(
        CM_POLICY_STRICT,
        CM_POLICY_SELFSIGNED,
        CM_POLICY_IGNORE,
    ),
    cmLocationType => FlowPDF::Types::Enum(
        CM_LOCATION_TYPE_PROPERTY,
        CM_LOCATION_TYPE_FILESYSTEM,
        CM_LOCATION_TYPE_SDA_CERT_STORAGE
    ),
    cmLocation => FlowPDF::Types::Scalar(),
    ec => FlowPDF::Types::Reference('ElectricCommander')
});


sub buildHook {
    my ($self, $opts) = @_;

    my $policy = $self->getCmPolicy();

    # Set default policy to strict
    if (!$policy) {
        $self->setCmPolicy(CM_POLICY_STRICT);
    }

    $self->{_tfhs} = [];
    return $self;
}


sub applyToLWP {
    my ($self, $ua) = @_;

    if (ref $ua ne 'LWP::UserAgent') {
        croak sprintf(
            '$ua parameter expected to be an LWP::UserAgent reference, got %s',
            ref $ua
        );
    }

    # now defining 2 branches of logic. 1st is for cb-perl
    # ec perl does not have any policy except ignore. So if policy is set to
    # self signed or strict, policy will be automatically switch to ignore and
    # warning will be thrown.
    my $policy = $self->getCmPolicy();
    my $locationType = $self->getCmLocationType();
    my $location = $self->getCmLocation();
    # if (isEcPerl() && ($policy eq CM_POLICY_STRICT || $policy eq CM_POLICY_SELFSIGNED)) {
    if (isEcPerl()) {
        $self->setCmPolicy(CM_POLICY_IGNORE);
        $ENV{PERL_LWP_SSL_VERIFY_HOSTNAME} = 0;
        return $ua;
    }

    # now is more complex scenario. cb-perl does support all policies so we have to react
    # by default policy is set to strict.
    if ($policy eq CM_POLICY_STRICT) {
        return $ua;
    }
    elsif ($policy eq CM_POLICY_IGNORE) {
        $ua->ssl_opts(verify_hostname => 0, SSL_verify_mode => 0);
        return $ua;
    }

    if ($policy ne CM_POLICY_SELFSIGNED) {
        # TODO: change to exception mechanism
        croak "Wrong policy: $policy";
    }

    if (!$locationType || !$location) {
        croak sprintf(
            'When policy is set to %s location type and certificates are mandatory',
            CM_POLICY_SELFSIGNED
        );
    }

    # now we need to handle self-signed policy
    my $sslOptsParams = {};
    # TODO: Implement property sheet support.
    if ($locationType eq CM_LOCATION_TYPE_PROPERTY) {
        if (!$self->getEc()) {
            croak sprintf(
                'ec object should be set if locationType is set to %s',
                CM_LOCATION_TYPE_PROPERTY
            )
        }
        # read property
        my $ec = $self->getEc();
        # TODO: Handle situation when property does not exist.
        my $certValue = $ec->getProperty($location)->findvalue('//value')->string_value();
        # create temp file
        my $tfh = File::Temp->new();
        my $filename = $tfh->filename();
        # add records to sslOptsParams
        $sslOptsParams->{SSL_ca_file} = $filename;
        # write property content to file
        print $tfh $certValue;
        close $tfh;
        # add closure to self object to avoid object destruction on end of $tfh life.
        push @{$self->{_tfhs}}, $tfh;
    }
    elsif ($locationType eq CM_LOCATION_TYPE_FILESYSTEM) {
        # check whether location does exist
        if (!-e $location) {
            # TODO: Add handling here
            croak sprintf(
                'filesystem path %s does not exist',
                $location
            );
        }
        # check whether it is file or directory
        # it is a directory
        if (-d $location) {
            $sslOptsParams->{SSL_ca_path} = $location;
        }
        # it is a file
        else {
            $sslOptsParams->{SSL_ca_file} = $location;
        }
        # add records to sslOptsParams
    }
    elsif ($locationType eq CM_LOCATION_TYPE_SDA_CERT_STORAGE) {
        croak sprintf(
            'Location type %s is not implemented yet',
            CM_LOCATION_TYPE_SDA_CERT_STORAGE
        );
    }
    # apply ssl_opts function of $ua.
    $ua->ssl_opts(%$sslOptsParams);
    # at this moment we already know that it is cb-perl
    # so we can apply ssl_opts to $ua object safely.
    return $ua;
}

1;
